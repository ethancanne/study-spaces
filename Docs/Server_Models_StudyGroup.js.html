<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: Server/Models/StudyGroup.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: Server/Models/StudyGroup.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const Mongoose = require("mongoose");
const Schema = Mongoose.Schema;

const Configuration = require("../../Configuration.js");
const Feed = require("./Feed");
const Log = require("../Log.js");
const { Meeting, MeetingAvailability } = require("./Meeting.js");
const MeetingFormats = require("./MeetingFormats.js");
const PrivacySettings = require("./PrivacySettings.js");
const ResponseMessages = require("../Responses/ResponseMessages.js");
const Subjects = require("./Subjects.js");
const User = require("./User.js");
const Validator = require("../Validator.js");

/**
 * Used to define the database schema for storing study groups.
 * @author Cliff Croom
 * @date   10/29/2021
 */
const StudyGroupSchema = new Schema({
    active: {
        type: Boolean,
        required: false
    },
    areaCode: {
        type: String,
        required: false
    },
    course: {
        type: String,
        required: false
    },
    feed: {
        type: Mongoose.Schema.Types.ObjectId,
        ref: Configuration.getFeedCollectionName(),
        required: true
    },
    groupColor: {
        type: String,
        required: true
    },
    isOnlineGroup: {
        type: Boolean,
        required: true
    },
    isTutorGroup: {
        type: Boolean,
        required: true
    },
    meetings: {
        type: [Mongoose.Schema.Types.ObjectId],
        ref: Configuration.getMeetingCollectionName(),
        required: true
    },
    members: {
        type: [Mongoose.Schema.Types.ObjectId],
        ref: Configuration.getUserCollectionName(),
        required: true
    },
    name: {
        type: String,
        required: true
    },
    owner: {
        type: Mongoose.Schema.Types.ObjectId,
        ref: Configuration.getUserCollectionName(),
        required: true
    },
    privacySetting: {
        type: String,
        required: true
    },
    recurringMeeting: {
        type: Mongoose.Schema.Types.ObjectId,
        ref: Configuration.getMeetingCollectionName(),
        required: false
    },
    school: {
        type: String,
        required: false
    },
    subject: {
        type: String,
        required: true
    },
    description: {
        type: String,
        required: false
    }
});
StudyGroupSchema.set("toObject", {
    versionKey: false,
    transform: (document, object) => {
        delete object.__v;
        return object;
    }
});

const studyGroupCollectionName = Configuration.getStudyGroupCollectionName();
const StudyGroupModel = Mongoose.model(studyGroupCollectionName, StudyGroupSchema);

/**
 * Provides an interface for working with study groups in the database.
 * @property {String} areaCode The area code for the study group.
 * @property {String=} course The course the study group is associated with.
 * @property {Mongoose.Schema.Types.ObjectId} feed The document ID for the study group's feed.
 * @property {Boolean} isOnlineGroup Indicates whether or not the study group is an online group.
 * @property {Boolean} isTutorGroup Indicates whether or not the study group is a tutor group.
 * @property {Mongoose.Schema.Types.ObjectId[]} members The list of document IDs for members in the study group.
 * @property {String} name The name of the study group.
 * @property {Mongoose.Schema.Types.ObjectId[]} oneTimeMeetings The list of one-off meetings associated with the study group.
 * @property {Mongoose.Schema.Types.ObjectId} owner The study group owner's document ID.
 * @property {Mongoose.Schema.Types.ObjectId=} recurringMeeting The study group's recurring meeting schedule.
 * @property {String=} school The school the study group is associated with.
 * @property {String} subject The subject the study group supports.
 * @author Cameron Burkholder
 * @date   10/29/2021
 */
class StudyGroup {
    /**
     * Initializes the study group to the group passed in from the database.
     * @param  {Mongoose.Schema} studyGroupSchema The database record for a given study group.
     * @author Cameron Burkholder
     * @date   10/29/2021
     */
    constructor(studyGroupSchema) {
        // COPY THE DATABASE INSTANCE TO THE MODEL INSTANCE.
        // In order to maximize the usability of this class, the attributes stored in the database
        // record are copied to the instance of this class so they can be properly editied.
        // The study group schema is converted to a regular object to sanitize it of wrapper methods and properties.
        Object.assign(this, studyGroupSchema.toObject());
    }

    /**
     * Adds a one-time meeting.
     * @param {Meeting} newMeeting The meeting to add.
     * @return {Boolean} True if the meeting was added, false otherwise.
     * @author Clifton Croom
     * @date 02/01/2022
     * @async
     */
    async addMeeting(newMeeting) {
        // ADD THE MEETING TO THE STUDY GROUP'S LIST OF MEMBERS.
        this.meetings.push(Mongoose.Types.ObjectId(newMeeting.getId()));

        // SAVE THE CHANGE.
        let meetingWasAdded = false;
        try {
            meetingWasAdded = await this.save();
        } catch (error) {
            Log.writeError(error);
        }
        return meetingWasAdded;
    }

    /**
     * Adds a member to the study group.
     * @param {User} newMember The member to add to the group.
     * @return {Boolean} True if the member was added, false otherwise.
     * @author Clifton Croom
     * @date 02/01/2022
     * @async
     */
    async addMember(newMember) {
        // ADD THE MEMBER TO THE STUDY GROUP'S LIST OF MEMBERS.
        this.members.push(newMember.getId());

        // SAVE THE CHANGE.
        let memberWasAdded = true;
        try {
            await this.save();
        } catch (error) {
            memberWasAdded = false;
            Log.writeError(error);
        }
        return memberWasAdded;
    }

    /**
     * Removes a member from the study group.
     * @param {User} The member to remove from the group.
     * @return {Boolean} True if the member was removed, false otherwise.
     * @author Stacey Popenfoose
     * @date 03/01/2022
     * @async
     */
    async removeMember(studyGroupMember) {
        // Remove THE MEMBER TO THE STUDY GROUP'S LIST OF MEMBERS.
        const members = this.members.map((memberId) => String(memberId));
        const memberIndex = members.indexOf(String(studyGroupMember.getId()));
        this.members.splice(memberIndex, 1);

        // SAVE THE CHANGE.
        let memberWasRemoved = true;
        try {
            await this.save();
        } catch (error) {
            memberWasRemoved = false;
            Log.writeError(error);
        }
        return memberWasRemoved;
    }

    /**
     * Creates a study group.
     * @param {String} name The study group name.
     * @param {User} owner The owner of the study group.
     * @param {String} subject The study group's subject.
     * @return {StudyGroup} The created study group.
     * @author Clifton Croom and Ethan Cannelongo
     * @date   11/30/2021
     * @async
     * @static
     */
    static async create(
        name,
        owner,
        subject,
        areaCode,
        isOnlineGroup,
        isTutorGroup,
        course,
        school,
        groupColor,
        description
    ) {
        // CREATE THE FEED ASSOCIATED WITH THE STUDY GROUP.
        const newFeed = await Feed.create();
        const newFeedId = Mongoose.Types.ObjectId(newFeed);

        // CREATE THE STUDY GROUP.
        const EMPTY_LIST_OF_MEETINGS = [];
        const EMPTY_LIST_OF_MEMBERS = [];
        const ownerId = owner.getId();
        const newStudyGroup = new StudyGroupModel({
            active: true,
            areaCode: areaCode,
            course: course,
            feed: newFeedId,
            isOnlineGroup: isOnlineGroup,
            isTutorGroup: isTutorGroup,
            meetings: EMPTY_LIST_OF_MEETINGS,
            members: EMPTY_LIST_OF_MEMBERS,
            name: name,
            owner: Mongoose.Types.ObjectId(ownerId),
            privacySetting: PrivacySettings.Open,
            school: school,
            subject: subject,
            groupColor,
            description
        });

        // SAVE THE STUDY GROUP.
        try {
            await newStudyGroup.save();
        } catch (error) {
            Log.writeError(error);
        }

        // INSTANTIATE THE MODEL.
        const studyGroup = new StudyGroup(newStudyGroup);
        return studyGroup;
    }

    /**
     * Deletes a study group.
     * @return {Boolean} True if the study group was deleted, false otherwise.
     * @author Cameron Burkholder
     * @date   02/12/2022
     * @async
     */
    async delete() {
        // DEACTIVE THE STUDY GROUP.
        let studyGroupDeleted = false;
        this.active = false;
        try {
            studyGroupDeleted = await this.save();
        } catch (error) {
            Log.write("An error occurred while attempting to delete a study group.");
            Log.writeError(error);
        }
        return studyGroupDeleted;
    }

    /**
     * Gets the study group's area code.
     * @return {String} The study group's area code.
     */
    getAreaCode() {
        return this.areaCode;
    }

    /**
     * Gets the study group's course.
     * @return {String} The study group's associated course.
     *
     */
    getCourse() {
        return this.course;
    }

    /**
     * Gets the study group's description.
     * @return {String} The study group's associated description.
     *
     */
    getDescription() {
        return this.description;
    }

    /**
     * Gets the study group feed.
     * @return {Boolean} True if the feed was found, false otherwise.
     * @author Cameron Burkholder
     * @date   02/14/2022
     * @async
     */
    async getFeed() {
        // GET THE DATABASE INSTANCE OF THE STUDY GROUP.
        let studyGroupModel;
        try {
            studyGroupModel = await StudyGroupModel.findOne({ _id: this.getId() });
        } catch (error) {
            Log.write("An error occurred while attempting to get the study group.");
            Log.writeError(error);
        }
        const studyGroupWasNotFound = Validator.isUndefined(studyGroupModel);
        if (studyGroupWasNotFound) {
            return undefined;
        }

        // GET THE STUDY GROUP'S FEED.
        let feedWasFound = false;
        try {
            feedWasFound = await studyGroupModel.populate("feed");
        } catch (error) {
            Log.write("An error occurred while attempting to get a study group's feed.");
            Log.writeError(error);
        } finally {
            if (feedWasFound) {
                this.feed = studyGroupModel.feed;
            }
            return feedWasFound;
        }
    }

    /**
     * Gets the study group's color.
     * @return {String} groupColor The study group's associated color.
     *
     */
    getGroupColor() {
        return this.groupColor;
    }

    /**
     * Gets the study group record from the database using the document ID.
     * @param  {String} studyGroupId The study group ID to search for.
     * @return {StudyGroup} The study group instance, if found; otherwise undefined.
     * @author Cliff Croom
     * @date   01/14/2022
     * @async
     * @static
     */
    static async getById(studyGroupId) {
        // CONVERT THE USER ID TO THE ACCEPTABLE TYPE.
        const convertedStudyGroupId = Mongoose.Types.ObjectId(studyGroupId);

        // GET THE USER BASED ON THE GIVEN ID.
        let studyGroupRecord = undefined;
        try {
            studyGroupRecord = await StudyGroupModel.findOne({ _id: convertedStudyGroupId }).exec();
        } catch (error) {
            Log.write("An error occurred while attempting to get a study group by ID.");
            Log.writeError(error);
            // If an error occurs, it should be returned.
            return error;
        } finally {
            // If the user wasn't able to be found in the database, this routine should return undefined.
            let studyGroup = undefined;
            let studyGroupWasFound = Validator.isDefined(studyGroupRecord);
            if (studyGroupWasFound) {
                // Since the userRecord is an instance of the UserSchema, it needs to be converted to an object.
                studyGroup = new StudyGroup(studyGroupRecord);
            }
            return studyGroup;
        }
    }

    /**
     * Gets the document id of the study group in the database as a string.
     * @return {String} The document id of the study group.
     */
    getId() {
        return this._id;
    }

    /**
     * Gets the study group's meetings.
     * @return {Boolean} True if the meetings were retrieved, false otherwise.
     * @author Cameron Burkholder
     * @date   02/21/2022
     * @async
     */
    async getMeetings() {
        // GET THE DATABASE INSTANCE OF THE STUDY GROUP.
        let studyGroupModel;
        try {
            studyGroupModel = await StudyGroupModel.findOne({ _id: this.getId() });
        } catch (error) {
            Log.write("An error occurred while attempting to get the study group.");
            Log.writeError(error);
        }
        const studyGroupWasNotFound = Validator.isUndefined(studyGroupModel);
        if (studyGroupWasNotFound) {
            return undefined;
        }

        // GET THE STUDY GROUP'S MEETINGS.
        let meetingsWereFound = false;
        try {
            meetingsWereFound = await studyGroupModel.populate("meetings");
        } catch (error) {
            Log.write("An error occurred while attempting to get a study group's meetings.");
            Log.writeError(error);
        } finally {
            if (meetingsWereFound) {
                this.meetings = studyGroupModel.meetings;
            }
            return meetingsWereFound;
        }
    }

    /**
     * Gets the study group's members.
     * @return {Boolean} True if the members were found, false otherwise.
     * @author Cameron Burkholder
     * @date   02/14/2022
     * @async
     */
    async getMembers() {
        // GET THE DATABASE INSTANCE OF THE STUDY GROUP.
        let studyGroupModel;
        try {
            studyGroupModel = await StudyGroupModel.findOne({ _id: this.getId() });
        } catch (error) {
            Log.write("An error occurred while attempting to get the study group.");
            Log.writeError(error);
        }
        const studyGroupWasNotFound = Validator.isUndefined(studyGroupModel);
        if (studyGroupWasNotFound) {
            return undefined;
        }

        // GET THE STUDY GROUP'S MEMBERS.
        let membersWereFound = false;
        try {
            membersWereFound = await studyGroupModel.populate("members");
        } catch (error) {
            Log.write("An error occurred while attempting to get a study group's members.");
            Log.writeError(error);
        } finally {
            if (membersWereFound) {
                this.members = studyGroupModel.members.map((memberModel) => {
                    memberModel.passwordHash = undefined;
                    return memberModel;
                });
            }
            return membersWereFound;
        }
    }

    /**
     * Gets the study group's name.
     * @return {String} The study group's name.
     */
    getName() {
        return this.name;
    }

    /**
     * Gets the study group's upcoming meeting.
     * @return {Meeting} The very next study group meeting.
     *
     * @async
     */
    async getNextMeeting() {}

    /**
     * Gets the study group's owner.
     * @return {User} The study group's owner.
     *
     * @async
     */
    async getOwner() {
        // GET THE DATABASE INSTANCE OF THE STUDY GROUP.
        let studyGroupModel;
        try {
            studyGroupModel = await StudyGroupModel.findOne({ _id: this.getId() });
        } catch (error) {
            Log.write("An error occurred while attempting to get the study group.");
            Log.writeError(error);
        }
        const studyGroupWasNotFound = Validator.isUndefined(studyGroupModel);
        if (studyGroupWasNotFound) {
            return undefined;
        }

        // GET THE STUDY GROUP'S OWNER.
        let ownerWasFound = false;
        try {
            ownerWasFound = await studyGroupModel.populate("owner");
        } catch (error) {
            Log.write("An error occurred while attempting to get a study group's owner.");
            Log.writeError(error);
        } finally {
            if (ownerWasFound) {
                this.owner = studyGroupModel.owner;
                this.owner.passwordHash = undefined;
            }
            return ownerWasFound;
        }
    }

    /**
     * Gets the study group's recurring meeting schedule.
     * @return {Boolean} True if the recurring meeting was found, false otherwise.
     * @author Cameron Burkholder
     * @date   02/21/2022
     * @async
     */
    async getRecurringMeeting() {
        // GET THE DATABASE INSTANCE OF THE STUDY GROUP.
        let studyGroupModel;
        try {
            studyGroupModel = await StudyGroupModel.findOne({ _id: this.getId() });
        } catch (error) {
            Log.write("An error occurred while attempting to get the study group.");
            Log.writeError(error);
        }
        const studyGroupWasNotFound = Validator.isUndefined(studyGroupModel);
        if (studyGroupWasNotFound) {
            return undefined;
        }

        // GET THE STUDY GROUP'S MEETINGS.
        let meetingWasFound = false;
        try {
            meetingWasFound = await studyGroupModel.populate("recurringMeeting");
        } catch (error) {
            Log.write("An error occurred while attempting to get a study group's recurring meeting.");
            Log.writeError(error);
        } finally {
            if (meetingWasFound) {
                this.recurringMeeting = studyGroupModel.recurringMeeting;
            }
            return meetingWasFound;
        }
    }

    /**
     * Gets the study group's school.
     * @return {String} The study group's school.
     */
    getSchool() {
        return this.school;
    }

    /**
     * Gets the study group's subject.
     * @return {String} The study group's subject.
     */
    getSubject() {
        return this.subject;
    }

    /**
     * Checks if a study group is active.
     * @return {Boolean} True if the group is active, false otherwise.
     */
    isActive() {
        const studyGroupIsActive = this.active ? true : false;
        return studyGroupIsActive;
    }

    /**
     * Checks if the group is an online group.
     * @return {Boolean} True if the group is an online group, false otherwise.
     */
    OnlineGroup() {
        return this.isOnlineGroup;
    }

    /**
     * Checks if the group is a tutor group.
     * @return {Boolean} True if the group is a tutor group, false otherwise.
     */
    getIsTutorGroup() {
        return this.isTutorGroup;
    }

    /**
     * Sets the group to be an in-person group.
     * @return {Boolean} True if the group was set to be in-person, false otherwise.
     * @author Cameron Burkholder
     * @date   02/15/2022
     * @async
     */
    async makeInPerson() {
        this.isOnlineGroup = false;
        let inPersonSet = false;
        try {
            inPersonSet = await this.save();
        } catch (error) {
            Log.write("An error occurred while attempting to make the study group in person.");
            Log.writeError(error);
        }
        return inPersonSet;
    }

    /**
     * Sets the group to be an online group.
     * @return {Boolean} True if the group was set to be an online group, false otherwise.
     * @author Cameron Burkholder
     * @date   02/15/2022
     * @async
     */
    async makeOnline() {
        this.isOnlineGroup = true;
        let isOnlineSet = false;
        try {
            isOnlineSet = await this.save();
        } catch (error) {
            Log.write("An error occurred while attempting to make the study group online.");
            Log.writeError(error);
        }
        return isOnlineSet;
    }

    /**
     * Sets the group to be a regular study group.
     * @return {Boolean} True if the group was set to be a regular study group, false otherwise.
     * @author Cameron Burkholder
     * @date   02/15/2022
     * @async
     */
    async makeStudyGroup() {
        this.isTutorGroup = false;
        let isTutorGroupSet = false;
        try {
            isTutorGroupSet = await this.save();
        } catch (error) {
            Log.write("An error occurred while attempting to make the study group a regular study group.");
            Log.writeError(error);
        }
        return isTutorGroupSet;
    }

    /**
     * Sets the group to be a tutor group.
     * @return {Boolean} True if the group was set to be a tutor group, false otherwise.
     * @author Cameron Burkholder
     * @date   02/15/2022
     * @async
     */
    async makeTutorGroup() {
        this.isTutorGroup = true;
        let isTutorGroupSet = false;
        try {
            isTutorGroupSet = await this.save();
        } catch (error) {
            Log.write("An error occurred while attempting to make the study group a tutor group.");
            Log.writeError(error);
        }
        return isTutorGroupSet;
    }

    /**
     * Removes a meeting from the study group's one-time meeting schedule.
     * @param {Meeting} meeting The meeting to remove.
     * @return {Booleam} True if the meeting was removed, false otherwise.
     *
     * @async
     */
    async removeMeeting(meeting) {
        //!!!!!
    }

    /**
     * This saves the associated user document in the database with the current properties
     * stored in this object.
     * @return {bool} True if the user was saved, false if the user wasn't saved.
     * @author Cameron Burkholder
     * @date  02/03/2022
     * @async
     */
    async save() {
        let studyGroupWasSaved = false;
        try {
            // GET THE DATABASE INSTANCE OF THE STUDY GROUP.
            let studyGroupModel = await StudyGroupModel.findOne({ _id: this._id }).exec();

            // UPDATE THE DATABASE INSTANCE WITH THE CURRENT USER PROPERTIES.
            Object.assign(studyGroupModel, this);

            // SAVE THE UPDATED DATABASE INSTANCE.
            await studyGroupModel.save();
            studyGroupWasSaved = true;
        } catch (error) {
            Log.write("An error occurred while attempting to retrieve the study group to save.");
            Log.writeError(error);
        } finally {
            return studyGroupWasSaved;
        }
    }

    /**
    * Returns study groups matching the user's search criteria.
    * @param {Object} filters The filters that define search criteria for a study group.
        These can be passed directly from the client to the server, as this method accounts
        for case differences in the search terms.
    * @return {StudyGroup[]} The list of study groups found matching the search criteria.
    * @author Cameron Burkholder
    * @date   01/25/2022
    */
    static async search(filters) {
        // CONVERT THE FILTERS QUERY INTO A MONGOOSE-READABLE FORMAT.
        // Since the filters query was defined to make more domain-level sense,
        // it must be converted to a form that Mongoose can parse to generate the search.
        // Additionally, using regex on the search term allows us to find all names, courses,
        // and subjects similar to the search term using the like operator from Mongoose.
        const searchTerm = new RegExp(`${filters.searchTerm}`, "i");

        let searchFilter = {
            $or: [{ name: searchTerm }, { course: searchTerm }]
        };

        // ADD OPTIONAL PARAMETERS TO THE SEARCH.
        const schoolFilteringIsEnabled = Validator.isDefined(filters.school) &amp;&amp; filters.school !== "";
        if (schoolFilteringIsEnabled) {
            // Using the regex format allows us to search for all school names
            // like the one entered.
            const schoolRegex = new RegExp(`${filters.school}`, "i");
            searchFilter.school = schoolRegex;
        }
        const subjectFilteringIsEnabled = Subjects.Any !== filters.subject;
        if (subjectFilteringIsEnabled) {
            searchFilter.subject = filters.subject;
        }

        // DETERMINE IF THE SEARCH SHOULD BE FOR TUTOR GROUPS.
        switch (filters.type) {
            case "Tutor":
                searchFilter.isTutorGroup = true;
                break;
            case "Group":
                searchFilter.isTutorGroup = false;
            case "Mixed":
            default:
                // If the user is searching for study groups that are tutor groups
                // or normal groups, then that is the same as performing a search without
                // specifying what the isTutorGroup attribute should be.
                break;
        }

        // DETERMINE THE TYPE OF GROUP BEING SEARCHED FOR.
        // The type of the group determines if the user is interested in seeing
        // groups that meet in-person, online, or both.
        switch (filters.meetingFormat) {
            case MeetingFormats.InPerson:
                searchFilter.isOnlineGroup = false;
                break;
            case MeetingFormats.Online:
                searchFilter.isOnlineGroup = true;
                break;
            case MeetingFormats.Mixed:
            default:
                // If the user is searching for study groups that are in person
                // or online, then that is the same as performing a search without
                // specifying what the isOnlineGroup attribute should be.
                break;
        }

        // FIND ALL STUDY GROUPS MATCHING THE SEARCH CONDITIONS.
        let studyGroups = undefined;
        try {
            studyGroups = await StudyGroupModel.find(searchFilter);
        } catch (error) {
            Log.write(
                `An error occurred while attempting to search for study groups matching the search filter: ${searchFilter}`
            );
            Log.writeError(error);
        }

        // FILTER STUDY GROUPS BASED ON PROXIMITY.
        // Since all requirements involving this element of the search
        // are marked as optional, this filter won't be applied in our current iteration.

        // FILL IN THE OWNER AND RECURRING MEETING ATTRIBUTES OF EACH STUDY GROUP.
        let studyGroupIndex = 0;
        while (studyGroupIndex &lt; studyGroups.length) {
            const studyGroup = studyGroups[studyGroupIndex];
            await studyGroup.populate("owner");
            studyGroup.owner.passwordHash = undefined;
            await studyGroup.populate("recurringMeeting");
            studyGroupIndex++;
        }

        // FILTER STUDY GROUPS BASED ON MEETING TIME AVAILABILITY.
        const meetingAvailability = new MeetingAvailability(
            filters.days,
            filters.meetingFrequencies,
            filters.startTime,
            filters.endTime
        );
        studyGroups = studyGroups.filter((studyGroup) => {
            if (studyGroup.active) {
                if (meetingAvailability.isOpen()) {
                    return true;
                } else {
                    if (Validator.isDefined(studyGroup.recurringMeeting)) {
                        const recurringMeeting = new Meeting(studyGroup.recurringMeeting);
                        const meetingTimeFitsSchedule = meetingAvailability.matchAvailability(recurringMeeting);
                        return meetingTimeFitsSchedule;
                    }
                }
            }
            return false;
        });

        // RETURN THE RESULTS IN ALPHABETICAL ORDER.
        studyGroups = studyGroups.sort((currentGroup, nextGroup) => {
            if (currentGroup.name &lt; nextGroup.name) {
                return -1;
            } else if (currentGroup.name > nextGroup.name) {
                return 1;
            } else {
                return 0;
            }
        });

        // RETURN THE STUDY GROUPS FOUND.
        return studyGroups;
    }

    /**
     * Sets the study group's area code.
     * @param {String} areaCode The area code to set.
     * @return {Boolean} True if the area code was set, false otherwise.
     * @author Cameron Burkholder
     * @date   02/15/2022
     * @async
     */
    async setAreaCode(areaCode) {
        this.areaCode = areaCode;
        let areaCodeSet = false;
        try {
            areaCodeSet = await this.save();
        } catch (error) {
            Log.write("An error occurred while attempting to set the area code.");
            Log.writeError(error);
        }
        return areaCodeSet;
    }

    /**
     * Sets the study group's course.
     * @param {String} courseName The course to set.
     * @return {Boolean} True if the course was set, false otherwise.
     * @author Cameron Burkholder
     * @date   02/15/2022
     * @async
     */
    async setCourse(courseName) {
        this.course = courseName;
        let courseSet = false;
        try {
            courseSet = await this.save();
        } catch (error) {
            Log.write("An error occurred while attempting to set the course.");
            Log.writeError(error);
        }
        return courseSet;
    }

    /**
     * Sets the study group's description.
     * @param {String} description The description to set.
     * @return {Boolean} True if the description was set, false otherwise.
     * @author Clifton Croom
     * @date   02/16/2022
     * @async
     */
    async setDescription(description) {
        this.description = description;
        let descriptionSet = false;
        try {
            descriptionSet = await this.save();
        } catch (error) {
            Log.write("An error occurred while attempting to set the description.");
            Log.writeError(error);
        }
        return descriptionSet;
    }

    /**
     * Sets the study group's color.
     * @param {String} color The color to set.
     * @return {Boolean} True if the color was set, false otherwise.
     * @author Cameron Burkholder
     * @date   02/15/2022
     * @async
     */
    async setGroupColor(color) {
        this.groupColor = color;
        let colorSet = false;
        try {
            colorSet = await this.save();
        } catch (error) {
            Log.write("An error occurred while attempting to set the group color.");
            Log.writeError(error);
        }
        return colorSet;
    }

    /**
     * Sets the study group's name.
     * @param {String} name The name to set.
     * @return {Boolean} True if the name was set, false otherwise.
     * @author Cameron Burkholder
     * @date   02/15/2022
     * @async
     */
    async setName(name) {
        this.name = name;
        let nameSet = false;
        try {
            nameSet = await this.save();
        } catch (error) {
            Log.write("An error occurred while attempting to set the name.");
            Log.writeError(error);
        }
        return nameSet;
    }

    /**
     * Sets the study group's recurring meeting.
     * @param {Mongoose.Types.ObjectId} meetingId The recurring meeting to set.
     * @return {Boolean} True if the recurring meeting was set, false otherwise.
     * @author Cameron Burkholder
     * @date   02/18/2022
     * @async
     */
    async setRecurringMeeting(meetingId) {
        this.recurringMeeting = meetingId;
        let recurringMeetingWasSet = false;
        try {
            recurringMeetingWasSet = await this.save();
        } catch (error) {
            Log.write(ResponseMessages.StudyGroup.SetRecurringMeeting.Error);
            Log.writeError(error);
        } finally {
            return recurringMeetingWasSet;
        }
    }

    /**
     * Sets the study group's school.
     * @param {String} school The school to set.
     * @return {Boolean} True if the school was set, false otherwise.
     * @author Cameron Burkholder
     * @date   02/15/2022
     * @async
     */
    async setSchool(school) {
        this.school = school;
        let schoolSet = false;
        try {
            schoolSet = await this.save();
        } catch (error) {
            Log.write("An error occurred while attempting to set the school.");
            Log.writeError(error);
        }
        return schoolSet;
    }

    /**
     * Sets the study group's subject.
     * @param {String} subject The subject to set.
     * @return {Boolean} True if the subject was set, false otherwise.
     * @author Cameron Burkholder
     * @date   02/15/2022
     * @async
     */
    async setSubject(subject) {
        this.subject = subject;
        let subjectSet = false;
        try {
            subjectSet = await this.save();
        } catch (error) {
            Log.write("An error occurred while attempting to set the subject.");
            Log.writeError(error);
        }
        return subjectSet;
    }

    /**
     * Updates the study group's meeting.
     * @param {Meeting} updatedMeeting The meeting to update.
     * @return {Boolean} True if the meeting was updated, false otherwise.
     *
     * @async
     */
    async updateMeeting(updatedMeeting) {}

    /**
     * Checks if the user is a member of the study group.
     * @param {User} user The user to check for study group membership.
     * @return {Boolean} True if the user is a member of the study group, false otherwise.
     * @author Cameron Burkholder
     * @date    02/03/2022
     */
    userIsAMember(user) {
        // CHECK IF THE STUDY GROUP'S MEMBER LIST CONTAINS THE USER.
        const userId = String(user.getId());
        // Converting the Object ID to a string ensures consistency in using the indexOf method.
        const studyGroupMemberIds = this.members.map((memberId) => String(memberId));
        const NOT_FOUND_INDEX = -1;
        const studyGroupHasUser = NOT_FOUND_INDEX !== studyGroupMemberIds.indexOf(userId);

        // CHECK IF THE USER'S STUDY GROUP LIST HAS THE STUDY GROUP.
        const userStudyGroupIds = user.studyGroups.map((studyGroupId) => String(studyGroupId));
        const studyGroupId = String(this.getId());
        const userHasStudyGroup = NOT_FOUND_INDEX !== userStudyGroupIds.indexOf(studyGroupId);

        // CHECK IF THE USER IS A MEMBER.
        // If the user is a valid member of the study group, both above conditions should be true.
        const userIsAMember = studyGroupHasUser &amp;&amp; userHasStudyGroup;

        // CHECK IF THE USER IS THE OWNER OF THE GROUP.
        const userIsOwner = this.userIsOwner(user);

        // CHECK IF THE USER IS IN THE STUDY GROUP.
        const userIsInStudyGroup = userIsAMember || userIsOwner;
        return userIsInStudyGroup;
    }

    /**
     * Checks if the user is the owner of the study group.
     * @param {User} user The user to check for study group ownership.
     * @return {Boolean} True if the user is the owner of the group, false otherwise.
     * @author Cameron Burkholder
     * @date   02/12/2022
     */
    userIsOwner(user) {
        // CHECK IF THE USER IS THE OWNER OF THE GROUP.
        const userId = String(user.getId());
        const studyGroupOwnerId = String(this.owner);
        const userIsOwner = studyGroupOwnerId === userId;
        return userIsOwner;
    }
}

module.exports = StudyGroup;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="AccountRouter.html">AccountRouter</a></li><li><a href="Authenticator.html">Authenticator</a></li><li><a href="Configuration.html">Configuration</a></li><li><a href="Conversation.html">Conversation</a></li><li><a href="Feed.html">Feed</a></li><li><a href="JsonWebTokenStrategyOptions.html">JsonWebTokenStrategyOptions</a></li><li><a href="Log.html">Log</a></li><li><a href="Meeting.html">Meeting</a></li><li><a href="MeetingAvailability.html">MeetingAvailability</a></li><li><a href="Message.html">Message</a></li><li><a href="MessageRouter.html">MessageRouter</a></li><li><a href="Post.html">Post</a></li><li><a href="ReportRouter.html">ReportRouter</a></li><li><a href="SearchRouter.html">SearchRouter</a></li><li><a href="StaticResourceRouter.html">StaticResourceRouter</a></li><li><a href="StudyGroup.html">StudyGroup</a></li><li><a href="StudyGroupRouter.html">StudyGroupRouter</a></li><li><a href="Time.html">Time</a></li><li><a href="UnverifiedUser.html">UnverifiedUser</a></li><li><a href="User.html">User</a></li><li><a href="Validator.html">Validator</a></li></ul><h3>Global</h3><ul><li><a href="global.html#Account">Account</a></li><li><a href="global.html#AccountSetupForm">AccountSetupForm</a></li><li><a href="global.html#AccountSetupView">AccountSetupView</a></li><li><a href="global.html#allReducers">allReducers</a></li><li><a href="global.html#App">App</a></li><li><a href="global.html#authReducer">authReducer</a></li><li><a href="global.html#Button">Button</a></li><li><a href="global.html#ButtonTypes">ButtonTypes</a></li><li><a href="global.html#ChatsView">ChatsView</a></li><li><a href="global.html#ConversationSchema">ConversationSchema</a></li><li><a href="global.html#ConversationView">ConversationView</a></li><li><a href="global.html#CreateAccountForm">CreateAccountForm</a></li><li><a href="global.html#CreateAccountView">CreateAccountView</a></li><li><a href="global.html#CreateMeetingView">CreateMeetingView</a></li><li><a href="global.html#CreatePostView">CreatePostView</a></li><li><a href="global.html#CreateStudyGroupForm">CreateStudyGroupForm</a></li><li><a href="global.html#CreateStudyGroupView">CreateStudyGroupView</a></li><li><a href="global.html#DetailsView">DetailsView</a></li><li><a href="global.html#Dropdown">Dropdown</a></li><li><a href="global.html#EditStudyGroupView">EditStudyGroupView</a></li><li><a href="global.html#FeedSchema">FeedSchema</a></li><li><a href="global.html#Form">Form</a></li><li><a href="global.html#generateRSAKeyPair">generateRSAKeyPair</a></li><li><a href="global.html#Home">Home</a></li><li><a href="global.html#InputField">InputField</a></li><li><a href="global.html#Label">Label</a></li><li><a href="global.html#LoginForm">LoginForm</a></li><li><a href="global.html#LoginView">LoginView</a></li><li><a href="global.html#MeetingFormats">MeetingFormats</a></li><li><a href="global.html#MeetingSchema">MeetingSchema</a></li><li><a href="global.html#MessageSchema">MessageSchema</a></li><li><a href="global.html#Notification">Notification</a></li><li><a href="global.html#notificationReducer">notificationReducer</a></li><li><a href="global.html#Page">Page</a></li><li><a href="global.html#Popup">Popup</a></li><li><a href="global.html#popupReducer">popupReducer</a></li><li><a href="global.html#PostSchema">PostSchema</a></li><li><a href="global.html#PostTypes">PostTypes</a></li><li><a href="global.html#PrivacySettings">PrivacySettings</a></li><li><a href="global.html#ResponseCodes">ResponseCodes</a></li><li><a href="global.html#ResponseMessages">ResponseMessages</a></li><li><a href="global.html#Routes">Routes</a></li><li><a href="global.html#Search">Search</a></li><li><a href="global.html#SearchForm">SearchForm</a></li><li><a href="global.html#SearchListing">SearchListing</a></li><li><a href="global.html#SearchResultView">SearchResultView</a></li><li><a href="global.html#SearchView">SearchView</a></li><li><a href="global.html#sendDeleteRequest">sendDeleteRequest</a></li><li><a href="global.html#sendGetRequest">sendGetRequest</a></li><li><a href="global.html#sendPostRequest">sendPostRequest</a></li><li><a href="global.html#sendPostRequestWithFormData">sendPostRequestWithFormData</a></li><li><a href="global.html#StaticResources">StaticResources</a></li><li><a href="global.html#Study">Study</a></li><li><a href="global.html#StudyGroupSchema">StudyGroupSchema</a></li><li><a href="global.html#studyGroupsReducer">studyGroupsReducer</a></li><li><a href="global.html#StudyGroupTypes">StudyGroupTypes</a></li><li><a href="global.html#StudyGroupView">StudyGroupView</a></li><li><a href="global.html#Subjects">Subjects</a></li><li><a href="global.html#TextInput">TextInput</a></li><li><a href="global.html#Toggle">Toggle</a></li><li><a href="global.html#ToggleField">ToggleField</a></li><li><a href="global.html#UnverifiedUserSchema">UnverifiedUserSchema</a></li><li><a href="global.html#UserSchema">UserSchema</a></li><li><a href="global.html#VerificationEmailConfirmationView">VerificationEmailConfirmationView</a></li><li><a href="global.html#ViewMeetingView">ViewMeetingView</a></li><li><a href="global.html#Views">Views</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.10</a> on Mon Mar 28 2022 09:51:20 GMT-0400 (Eastern Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
