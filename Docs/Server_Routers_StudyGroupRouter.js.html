<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: Server/Routers/StudyGroupRouter.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: Server/Routers/StudyGroupRouter.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const multer = require("multer");
const Path = require("path");
const sharp = require("sharp");

const Authenticator = require("../Authenticator.js");
const Configuration = require("../../Configuration.js");
const Feed = require("../Models/Feed.js");
const Log = require("../Log.js");
const { Meeting } = require("../Models/Meeting.js");
const PrivacySettings = require("../Models/PrivacySettings.js");
const ResponseCodes = require("../Responses/ResponseCodes.js");
const ResponseMessages = require("../Responses/ResponseMessages.js");
const Routes = require("../Routes/Routes.js");
const StaticResources = require("../Routes/StaticResources.js");
const StudyGroup = require("../Models/StudyGroup.js");
const Validator = require("../Validator.js");
const User = require("../Models/User.js");
const { request } = require("http");
const { getById } = require("../Models/User.js");
const { Days } = require("../Models/Time.js");

/**
 * The router used to serve account-related requests.
 * @author Clifton Croom
 * @date   11/17/2021
 */
class StudyGroupRouter {
    /**
     * Initialize the router and serve the routes.
     * @param {Server} server The server instance used to provide the routes.
     * @param {Authenticator} authenticator The authenticator used to protect the routes.
     * @author Clifton Croom
     * @date   11/17/2021
     * @static
     */
    static serveRoutes(server, authenticator) {
        // This is used to allow users to upload profile pictures.
        const fileFilter = (req, file, cb) => {
            const allowedFileTypes = ["image/jpeg", "image/jpg", "image/png"];
            if (allowedFileTypes.includes(file.mimetype)) {
                cb(null, true);
            } else {
                req.profilePictureFailed = true;
                Log.write("The file format is not supported.");
                cb(null, false, req.profilePictureFailed);
            }
        };

        //Limit the file size
        const upload = multer({
            limits: {
                fileSize: 2000000
            },
            fileFilter: fileFilter
        });

        // Used to add one-time meetings.
        server.post(
            Routes.StudyGroup.AddOneTimeMeeting,
            authenticator.protectRoute(),
            StudyGroupRouter.addOneTimeMeeting
        );
        // Used to create posts.
        server.post(
            Routes.StudyGroup.CreatePost,
            authenticator.protectRoute(),
            upload.single("attachment"),
            StudyGroupRouter.createPost
        );

        // This is used to create study groups.
        server.post(
            Routes.StudyGroup.CreateStudyGroup,
            authenticator.protectRoute(),
            Validator.validateCreateStudyGroupInput,
            StudyGroupRouter.createStudyGroup
        );
        // Used to delete a study group.
        server.delete(
            Routes.StudyGroup.DeleteStudyGroup,
            authenticator.protectRoute(),
            StudyGroupRouter.deleteStudyGroup
        );

        //Used to delete a meeting.
        server.delete(Routes.StudyGroup.DeleteMeeting, authenticator.protectRoute(), StudyGroupRouter.deleteMeeting);

        // This is used to edit a meeting.
        server.post(Routes.StudyGroup.EditMeeting, authenticator.protectRoute(), StudyGroupRouter.editOneTimeMeeting);

        // This is used to edit a study group.
        server.post(Routes.StudyGroup.EditStudyGroup, authenticator.protectRoute(), StudyGroupRouter.editStudyGroup);
        // This is used to get a specific study group.
        server.get(Routes.StudyGroup.GetStudyGroup, authenticator.protectRoute(), StudyGroupRouter.getStudyGroup);
        // This is used to get a user's study groups.
        server.get(
            Routes.StudyGroup.GetUserStudyGroups,
            authenticator.protectRoute(),
            StudyGroupRouter.getUserStudyGroups
        );
        // This is used to join a study group.
        server.post(Routes.StudyGroup.JoinStudyGroup, authenticator.protectRoute(), StudyGroupRouter.joinStudyGroup);

        //This is used to leave a study group.
        server.post(Routes.StudyGroup.LeaveStudyGroup, authenticator.protectRoute(), StudyGroupRouter.leaveStudyGroup);

        // Used to set recurring meetings.
        server.post(
            Routes.StudyGroup.SetRecurringMeeting,
            authenticator.protectRoute(),
            StudyGroupRouter.setRecurringMeeting
        );
    }

    /**
     * Allows the study group owner to add a one-time meeting.
     * @param {String} request.body.date The date the meeting occurs.
     * @param {String} request.body.studyGroupId The group ID.
     * @param {String} request.body.time The time the meeting occurs.
     * @param {String=} request.body.day The day of the meeting.
     * @param {String=} request.body.details Information about the meeting.
     * @param {String=} request.body.location The location of the meeting.
     * @param {String=} request.body.roomNumber The room number of the meeting location.
     * @author Cameron Burkholder
     * @date   02/21/2022
     * @async
     * @static
     */
    static async addOneTimeMeeting(request, response) {
        // CHECK THAT THE USER IS THE OWNER OF THE STUDY GROUP.
        const user = request.user;
        const studyGroupId = request.body.studyGroupId;
        let studyGroup = await StudyGroup.getById(studyGroupId);
        // Check that the study group exists.
        const studyGroupWasFound = Validator.isDefined(studyGroup);
        if (!studyGroupWasFound) {
            return reponse.json({ message: ResponseMessages.StudyGroup.UserNotOwner });
        }

        // CHECK IF THE USER IS THE OWNER OF THE STUDY GROUP.
        const userIsOwner = studyGroup.userIsOwner(user);
        if (!userIsOwner) {
            return response.json({ message: ResponseMessages.StudyGroup.UserNotOwner });
        }

        // CREATE THE ONE-TIME MEETING.
        const { day, time, date, details, location, roomNumber } = request.body;
        const oneTimeMeeting = await Meeting.createOneTime(date, time, day, details, location, roomNumber);

        // ADD THE ONE-TIME MEETING.
        let oneTimeMeetingWasSet = await studyGroup.addMeeting(oneTimeMeeting);
        if (oneTimeMeetingWasSet) {
            return response.json({ message: ResponseMessages.StudyGroup.AddOneTimeMeeting.Success });
        } else {
            return response.json({ message: ResponseMessages.StudyGroup.AddOneTimeMeeting.Error });
        }
    }

    /**
     * @param {String} request.body.title The post title.
     * @param {String} request.body.message The post contents.
     * @param {String} request.body.type The type of post being created.
     * @author Cameron Burkholder
     * @date   03/04/2022
     */
    static async createPost(request, response) {
        // CHECK THAT THE ATTACHMENT (IF PROVIDED) HAS NOT FAILED.
        if (request.profilePictureFailed) {
            return response.json({ message: ResponseMessages.StudyGroup.CreatePost.InvalidAttachment });
        }

        // GET THE STUDY GROUP.
        const studyGroupId = request.body.studyGroupId;
        const studyGroup = await StudyGroup.getById(studyGroupId);
        const studyGroupWasNotFound = Validator.isUndefined(studyGroup);
        if (studyGroupWasNotFound) {
            return response.json({ message: ResponseMessages.StudyGroup.StudyGroupNotFound });
        }

        // CHECK THAT THE USER IS IN THE STUDY GROUP.
        const user = request.user;
        const userIsInStudyGroup = studyGroup.userIsAMember(user);
        if (!userIsInStudyGroup) {
            return response.json({ message: ResponseMessages.StudyGroup.UserNotInStudyGroup });
        }

        // GET THE STUDY GROUP'S FEED.
        const feedWasFound = await studyGroup.getFeed();
        if (!feedWasFound) {
            return response.json({ message: ResponseMessages.StudyGroup.CreatePost.Error });
        }
        const feed = new Feed(studyGroup.feed);

        // CREATE THE POST.
        const { title, message, type } = request.body;
        const creator = user.getId();
        const feedId = feed.getId();
        // It is not required to upload an attachment, but if one has been uploaded
        // it must be processed in order to be stored in the database.
        let attachment = undefined;
        console.log(request.body);
        const attachmentWasIncluded = Validator.isDefined(request.file);
        if (Validator.isDefined(request.file)) {
            const convertedAttachment = await sharp(request.file.buffer)
                .resize({ height: 200, width: 200 })
                .png()
                .toBuffer();
            attachment = convertedAttachment.toString("base64");
        }
        const postWasCreated = await feed.addPost(title, message, feedId, creator, type, attachment);
        if (!postWasCreated) {
            return response.json({ message: ResponseMessages.StudyGroup.CreatePost.Error });
        }

        // GET THE UPDATED FEED.
        const posts = await feed.getPosts();
        const postsWereFound = Validator.isDefined(posts);
        if (postsWereFound) {
            return response.json({
                message: ResponseMessages.StudyGroup.CreatePost.Success,
                posts: posts
            });
        } else {
            return response.json({
                message: ResponseMessages.StudyGroup.CreatePost.Error
            });
        }
    }

    /**
     * @param {String} request.body.meetingId
     * @param {String} request.body.studyGroupId
     * @author Clif Croom
     */
    static async deleteMeeting(request, response) {
        // GET THE ASSOCIATED STUDY GROUP.
        const studyGroup = await StudyGroup.getById(request.body.studyGroupId);
        if (!Validator.isDefined(studyGroup)) {
            return response.json({ message: ResponseMessages.StudyGroup.StudyGroupNotFound });
        }

        // CHECK THAT THE USER OWNS THE STUDY GROUP.
        const user = request.user;
        const userIsOwner = studyGroup.userIsOwner(user);
        if (!userIsOwner) {
            return response.json({ message: ResponseMessages.studyGroup.UserNotOwner });
        }
        // CHECK THAT THE MEETING BELONGS TO THE STUDY GROUP.
        const meetingId = request.body.meetingId;
        // Converting the Object ID to a string ensures consistency in using the indexOf method.
        const studyGroupMeetingIds = studyGroup.meetings.map((meeetingId) => String(meetingId));
        const NOT_FOUND_INDEX = -1;
        const studyGroupHasMeeting = NOT_FOUND_INDEX !== studyGroupMeetingIds.indexOf(meetingId);
        if (!studyGroupHasMeeting) {
            return response.json({ message: ResponseMessages.StudyGroup.ErrorDeleteMeeting });
        }

        //Get meeting to edit.
        let meeting = undefined;
        try {
            meeting = await Meeting.getById(request.body.meetingId);
        } catch (error) {
            Log.write("An error occurred while attempting to get the meeting.");
            Log.writeError(error);
            return response.json({ message: ResponseMessages.StudyGroup.ErrorEditMeeting });
        }
        //Check if the meeting was found.
        const meetingWasNotFound = Validator.isUndefined(meeting);
        if (meetingWasNotFound) {
            return response.json({ message: ResponseMessages.StudyGroup.MeetingNotFound });
        }

        // Delete the meeting
        let meetingDeleted = false;
        try {
            meetingDeleted = await meeting.delete();
        } catch (error) {
            Log.write("An error occurred while attempting to delete the meeting.");
            Log.writeError(error);
        }
        const meetingIndex = studyGroupMeetingIds.indexOf(meetingId);
        studyGroup.meetings.splice(meetingId, 1);
        const studyGroupWasSaved = await studyGroup.save();
        if (!studyGroupWasSaved) {
            return response.json({ message: ResponseMessages.StudyGroup.ErrorDeleteMeeting });
        }
        return response.json({ message: ResponseMessages.StudyGroup.SuccessDeleteMeeting });
    }

    /**
     *
     * @param {String} request.body.date The date the meeting occurs.
     * @param {String} request.body.time The time the meeting occurs.
     * @param {String} request.body.day The day of the meeting.
     * @param {String} request.body.details Information about the meeting.
     * @param {String} request.body.location The location of the meeting.
     * @param {String} request.body.roomNumber The room number of the meeting location.
     * @param {String} request.body.meetingId The meeting identifier for the meeting to edit.
     * @author Clifton Croom
     * @date 02/22/22
     * @async
     * @static
     */
    static async editOneTimeMeeting(request, response) {
        let meeting = undefined;

        //Get meeting to edit.
        try {
            meeting = await Meeting.getById(request.body.meetingId);
        } catch (error) {
            Log.write("An error occurred while attempting to get the meeting.");
            Log.writeError(error);
            response.status(ResponseCodes.Error);
            return response.json({ message: ResponseMessages.StudyGroup.ErrorEditMeeting });
        }

        const meetingWasNotFound = Validator.isUndefined(meeting);
        if (meetingWasNotFound) {
            return response.json({ message: ResponseMessages.StudyGroup.MeetingNotFound });
        }

        //Compare original meeting to new meeting to check for differences

        if (request.body.date != meeting.getDate()) {
            if (request.body.date == null) {
                return response.json({ message: "Date is a required attribute." });
            } else {
                meeting.setDate(request.body.date);
            }
        }

        if (request.body.time != meeting.getTime()) {
            if (request.body.time == null) {
                return response.json({ message: "Time is a required attribute." });
            } else {
                meeting.setTime(request.body.time);
            }
        }

        if (request.body.day != meeting.getDay()) {
            if (request.body.day == null) {
                return response.json({ message: "Day is a required attribute." });
            } else {
                meeting.setDay(request.body.day);
            }
        }

        if (request.body.details != meeting.getDetails()) {
            meeting.setDetails(request.body.details);
        }

        if (request.body.location != meeting.getLocation()) {
            meeting.setLocation(request.body.location);
        }

        if (request.body.roomNumber != meeting.getRoomNumber()) {
            meeting.setRoomNumber(request.body.roomNumber);
        }

        //Return the edited meeting
        return response.json({
            message: ResponseMessages.StudyGroup.SuccessMeetingEdited,
            meeting: meeting
        });
    }

    /**
     * @param {String} request.body.name The name of the study group being created.
     * @param {String} request.body.subject The subject of the study group being created.
     * @param {String} request.body.areaCode The area code of the study group being created.
     * @param {String} request.body.inOnlineGroup True if the group is online, false otherwise.
     * @param {String} request.body.isTutorGroup True if the group is a tutor group, false otherwise.
     * @param {String} request.body.course The course of the study group being created.
     * @param {String} request.user The user creating the study group.
     * @author Clifton Croom
     * @date   11/30/21
     * @async
     * @static
     */
    static async createStudyGroup(request, response) {
        // CREATE STUDY GROUP.
        let newStudyGroup = undefined;
        try {
            newStudyGroup = await StudyGroup.create(
                request.body.name,
                request.user,
                request.body.subject,
                request.body.areaCode,
                request.body.isOnlineGroup,
                request.body.isTutorGroup,
                request.body.course,
                request.body.school,
                request.body.groupColor,
                request.body.description
            );
        } catch (error) {
            Log.writeError(error);
        }
        const studyGroupWasNotCreated = Validator.isUndefined(newStudyGroup);

        // VALIDATE STUDY GROUP CREATION.
        if (studyGroupWasNotCreated) {
            return response.json({ message: ResponseMessages.StudyGroup.ErrorCreateStudyGroup });
        }

        // ADD THE STUDY GROUP TO THE USER.
        let studyGroupWasAdded = false;
        try {
            studyGroupWasAdded = await request.user.addStudyGroup(newStudyGroup);
        } catch (error) {
            Log.writeError(error);
        }
        if (!studyGroupWasAdded) {
            return response.json({ message: ResponseMessages.StudyGroup.ErrorCreateStudyGroup });
        }

        // SEND SUCCESS MESSAGE
        response.json({
            message: ResponseMessages.StudyGroup.SuccessStudyGroupCreated,
            newStudyGroup: newStudyGroup
        });
    }

    /**
     * Deletes a study group.
     * @param {String} request.body.studyGroupId
     * @author Cameron Burkholder
     * @date   02/12/2022
     * @async
     * @static
     */
    static async deleteStudyGroup(request, response) {
        // GET THE STUDY GROUP.
        const studyGroupId = request.body.studyGroupId;
        let studyGroup = undefined;
        try {
            studyGroup = await StudyGroup.getById(studyGroupId);
        } catch (error) {
            Log.write("An error occurred while attempting to get the study group.");
            Log.writeError(error);
            response.status(ResponseCodes.Error);
            return response.json({ message: ResponseMessages.StudyGroup.ErrorDeleteStudyGroup });
        }
        const studyGroupWasNotFound = Validator.isUndefined(studyGroup);
        if (studyGroupWasNotFound) {
            return response.json({ message: ResponseMessages.StudyGroup.StudyGroupNotFound });
        }

        // CHECK THAT THE REQUESTING USER IS AN OWNER OF THE STUDY GROUP.
        const userIsOwner = studyGroup.userIsOwner(request.user);
        if (!userIsOwner) {
            response.status(ResponseCodes.Unauthorized);
            return response.json({ message: ResponseMessages.StudyGroup.UserNotOwner });
        }

        // DELETE THE STUDY GROUP.
        let studyGroupDeleted = false;
        try {
            studyGroupDeleted = await studyGroup.delete();
        } catch (error) {
            Log.write("An error occurred while attempting to delete the study group.");
            Log.writeError(error);
            response.status(ResponseCodes.Error);
            return response.json({ message: ResponseMessages.StudyGroup.ErrorDeleteStudyGroup });
        }
        if (!studyGroupDeleted) {
            response.status(ResponseCodes.Error);
            return response.json({ message: ResponseMessages.StudyGroup.ErrorDeleteStudyGroup });
        }
        return response.json({ message: ResponseMessages.StudyGroup.SuccessStudyGroupDeleted });
    }

    /**
     * A route to edit one or more details of a study group.
     * @param {String} request.body.course
     * @param {String} request.body.description
     * @param {String} request.body.groupColor
     * @param {Boolean} request.body.isOnlineGroup
     * @param {Boolean} request.body.isTutorGroup
     * @param {String} request.body.name
     * @param {String} request.body.subject
     * @param {Object} request.body.studyGroupId
     * @author Clifton Croom
     * @date 02/16/2022
     * @async
     * @static
     */
    static async editStudyGroup(request, response) {
        //GET ORIGINAL STUDY GROUP
        const studyGroupId = request.body.studyGroupId;
        let studyGroup = undefined;
        console.log(request.body.studyGroupId);
        try {
            studyGroup = await StudyGroup.getById(studyGroupId);
        } catch (error) {
            Log.write("An error occurred while attempting to get the study group.");
            Log.writeError(error);
            response.status(ResponseCodes.Error);
            return response.json({ message: ResponseMessages.StudyGroup.ErrorGetStudyGroup });
        }

        const studyGroupWasNotFound = Validator.isUndefined(studyGroup);
        if (studyGroupWasNotFound) {
            return response.json({ message: ResponseMessages.StudyGroup.StudyGroupNotFound });
        }

        console.log(studyGroup.getCourse());
        // CHECK FOR EDITS AND MAKE CHANGES IF NECESSARY

        //Check for new study group course
        if (request.body.course != studyGroup.getCourse()) {
            studyGroup.setCourse(request.body.course);
        }
        console.log(studyGroup.getCourse());

        //Check for new study group description
        if (request.body.description != studyGroup.getDescription()) {
            studyGroup.setDescription(request.body.description);
        }

        //Check for new color
        if (request.body.groupColor != studyGroup.getGroupColor()) {
            studyGroup.setGroupColor(request.body.groupColor);
        }

        //Check for change in study group mode
        if (request.body.isOnlineGroup != studyGroup.OnlineGroup()) {
            if (studyGroup.OnlineGroup()) {
                studyGroup.makeInPerson();
            } else {
                studyGroup.makeOnline();
            }
        }

        //Check for change in study group type
        if (request.body.isTutorGroup != studyGroup.getIsTutorGroup()) {
            if (studyGroup.getIsTutorGroup()) {
                studyGroup.makeStudyGroup();
            } else {
                studyGroup.makeTutorGroup();
            }
        }

        //Check for change in study group name
        if (request.body.name != studyGroup.getName()) {
            if (request.body.name == null) {
                return response.json({ message: ResponseMessages.StudyGroup.ErrorNullStudyGroupInput });
            }
            studyGroup.setName(request.body.name);
        }

        //Check for change in study group subject
        if (request.body.subject != studyGroup.getSubject()) {
            if (request.body.subject == null) {
                return response.json({ message: ResponseMessages.StudyGroup.ErrorNullStudyGroupInput });
            }
            studyGroup.setSubject(request.body.subject);
        }

        //RETURN SUCCESS MESSAGE
        return response.json({
            message: ResponseMessages.StudyGroup.SuccessStudyGroupEdited,
            studyGroup: studyGroup
        });
    }

    /**
     * Gets the study group with a given study group ID.
     * @param {String} request.query.studyGroupId The study group ID.
     * @author Cameron Burkholder
     * @date   02/12/2022
     * @async
     * @static
     */
    static async getStudyGroup(request, response) {
        // GET THE STUDY GROUP.
        const studyGroupId = request.query.studyGroupId;
        let studyGroup = undefined;
        try {
            studyGroup = await StudyGroup.getById(studyGroupId);
        } catch (error) {
            Log.write("An error occurred while attempting to get the study group.");
            Log.writeError(error);
            response.status(ResponseCodes.Error);
            return response.json({ message: ResponseMessages.StudyGroup.ErrorGetStudyGroup });
        }
        const studyGroupWasNotFound = Validator.isUndefined(studyGroup);
        if (studyGroupWasNotFound) {
            return response.json({ message: ResponseMessages.StudyGroup.StudyGroupNotFound });
        }

        // CHECK THAT THE REQUESTING USER IS ON THE STUDY GROUP.
        const userIsAMember = studyGroup.userIsAMember(request.user);
        if (!userIsAMember) {
            response.status(ResponseCodes.Unauthorized);
            return response.json({ message: ResponseMessages.StudyGroup.UserNotInStudyGroup });
        }

        // CHECK THAT THE STUDY GROUP IS ACTIVE.
        const studyGroupIsActive = studyGroup.isActive();
        if (!studyGroupIsActive) {
            return response.json({ message: ResponseMessages.StudyGroup.StudyGroupIsNotActive });
        }

        // POPULATE THE STUDY GROUP'S OWNER.
        let ownerWasFound = await studyGroup.getOwner();
        if (!ownerWasFound) {
            response.status(ResponseCodes.Error);
            return response.json({ message: ResponseMessages.StudyGroup.ErrorGetStudyGroup });
        }

        // POPULATE THE STUDY GROUP'S MEMBERS.
        let membersWereFound = false;
        membersWereFound = await studyGroup.getMembers();
        if (!membersWereFound) {
            response.status(ResponseCodes.Error);
            return response.json({ message: ResponseMessages.StudyGroup.ErrorGetStudyGroup });
        }

        // POPULATE THE STUDY GROUP'S FEED.
        let feedWasPopulated = false;
        feedWasPopulated = await studyGroup.getFeed();
        if (!feedWasPopulated) {
            response.status(ResponseCodes.Error);
            return response.json({ message: ResponseMessages.StudyGroup.ErrorGetStudyGroup });
        }
        const feed = new Feed(studyGroup.feed);
        const posts = await feed.getPosts();
        const postsWereFound = Validator.isDefined(posts);
        if (!postsWereFound) {
            return response.json({ message: ResponseMessages.StudyGroup.ErrorGetStudyGroup });
        }
        studyGroup.posts = posts;

        // POPULATE THE STUDY GROUP'S MEETINGS.
        let meetingsWereFound = await studyGroup.getMeetings();
        if (!meetingsWereFound) {
            response.status(ResponseCodes.Error);
            return response.json({ message: ResponseMessages.StudyGroup.ErrorGetStudyGroup });
        }

        // POPULATE THE STUDY GROUP'S RECURRING MEETING.
        let recurringMeetingWasFound = await studyGroup.getRecurringMeeting();
        if (!recurringMeetingWasFound) {
            response.status(ResponseCodes.Error);
            return response.json({ message: ResponseMessages.StudyGroup.ErrorGetStudyGroup });
        }

        // RETURN THE STUDY GROUP.
        return response.json({
            message: ResponseMessages.StudyGroup.SuccessStudyGroupRetrieved,
            studyGroup: studyGroup
        });
    }

    /**
     * Gets the study groups a user has joined.
     * @param
     * @author Ethan Cannelongo
     * @date   01/14/2022
     * @async
     * @static
     */
    static async getUserStudyGroups(request, response) {
        // CREATE STUDY GROUP.
        let studyGroups = undefined;
        try {
            studyGroups = await request.user.getStudyGroups();
        } catch (error) {
            Log.writeError(error);
        } finally {
            // SEND SUCCESS MESSAGE.
            if (Validator.isDefined(studyGroups)) {
                response.json({
                    message: ResponseMessages.StudyGroup.SuccessStudyGroupsRetrieved,
                    studyGroups: studyGroups
                });
            } else {
                response.json({ message: ResponseMessages.StudyGroup.ErrorCreateStudyGroup });
            }
        }
    }

    /**
     * Allows a user to join a study group.
     * @author Cameron Burkholder
     * @date   02/03/2022
     * @async
     * @static
     */
    static async joinStudyGroup(request, response) {
        // GET THE USER JOINING THE GROUP.
        const user = request.user;

        // GET THE STUDY GROUP BEING JOINED.
        let studyGroup = undefined;
        try {
            studyGroup = await StudyGroup.getById(request.body.studyGroupId);
        } catch (error) {
            Log.write("An error occurred while attempting to join a study group.");
            Log.writeError(error);
            response.status(ResponseCodes.Error);
        }
        const studyGroupWasNotFound = Validator.isUndefined(studyGroup);
        if (studyGroupWasNotFound) {
            return response.json({ message: ResponseMessages.StudyGroup.ErrorJoinStudyGroup });
        }

        // CHECK IF THE USER IS ALREADY IN THE STUDY GROUP.
        const userAlreadyJoinedStudyGroup = studyGroup.userIsAMember(user);
        if (userAlreadyJoinedStudyGroup) {
            return response.json({ message: ResponseMessages.StudyGroup.UserAlreadyJoined });
        }

        // CHECK IF THE USER IS THE OWNER OF THE STUDY GROUP.
        const userIsOwnerOfStudyGroup = String(request.user.getId()) === String(studyGroup.owner);
        if (userIsOwnerOfStudyGroup) {
            return response.json({ message: ResponseMessages.StudyGroup.UserAlreadyJoined });
        }

        // CHECK IF THE USER IS ASSOCIATED WITH THE SAME SCHOOL AS THE STUDY GROUP
        const userIsNotAssociatedWithSameSchool =
            request.user.getSchool() !== studyGroup.school &amp;&amp; studyGroup.school !== "";
        if (userIsNotAssociatedWithSameSchool) {
            return response.json({ message: ResponseMessages.StudyGroup.UserNotAssociatedWithSchoolOfStudyGroup });
        }

        // CHECK IF THE STUDY GROUP HAS ITS PRIVACY SETTING SET TO OPEN OR PRIVATE.
        // Since we elected to make the private study group an optional feature,
        // checking this is merely done to provide flexibility for future teams.
        const studyGroupIsOpen = PrivacySettings.Open === studyGroup.privacySetting;
        if (studyGroupIsOpen) {
            // ADD THE USER TO THE STUDY GROUP.
            // Since the membership of a study group is identified in two places,
            // the user will need to be added to the study group's member list as
            // well as adding the study group to the user's study group list.
            let userWasAddedToStudyGroup = false;
            try {
                userWasAddedToStudyGroup = await studyGroup.addMember(user);
            } catch (error) {
                Log.write("An error occurred while attempting to add a user to a study group.");
                Log.writeError(error);
                response.status(ResponseCodes.Error);
            }
            if (!userWasAddedToStudyGroup) {
                return response.json({ message: ResponseMessages.StudyGroup.ErrorJoinStudyGroup });
            }

            // ADD THE STUDY GROUP TO THE USER.
            let studyGroupWasAddedToUser = false;
            try {
                studyGroupWasAddedToUser = await user.addStudyGroup(studyGroup);
            } catch (error) {
                Log.write("An error ocurred while attempting to add a study group to a user.");
                Log.writeError(error);
                response.status(ResponseCodes.Error);
            }
            if (!studyGroupWasAddedToUser) {
                return response.json({ message: ResponseMessages.StudyGroup.ErrorJoinStudyGroup });
            }
        } else {
            // Nothing needs done here in this iteration of the project.
        }

        // SEND THE RESPONSE.
        // If execution reaches this point then the user has successfully been added to the study group.
        return response.json({ message: ResponseMessages.StudyGroup.SuccessStudyGroupJoined });
    }

    /**
     * Allows a user to leave a study group.
     * @author Clifton Croom
     * @date   03/02/2022
     * @async
     * @static
     */
    static async leaveStudyGroup(request, response) {
        // GET THE USER LEAVING THE GROUP.
        const user = request.user;

        // GET THE STUDY GROUP BEING LEFT.
        let studyGroup = undefined;
        try {
            studyGroup = await StudyGroup.getById(request.body.studyGroupId);
        } catch (error) {
            Log.write("An error occurred while attempting to leave a study group.");
            Log.writeError(error);
            response.status(ResponseCodes.Error);
        }

        const studyGroupWasNotFound = Validator.isUndefined(studyGroup);
        if (studyGroupWasNotFound) {
            return response.json({ message: ResponseMessages.StudyGroup.ErrorLeaveStudyGroup });
        }

        // REMOVE THE USER TO THE STUDY GROUP.
        let userWasRemoved = false;
        try {
            userWasRemoved = await studyGroup.removeMember(user);
        } catch (error) {
            Log.write("An error occurred while attempting to remove a user from a study group.");
            Log.writeError(error);
            response.status(ResponseCodes.Error);
        }
        if (!userWasRemoved) {
            return response.json({ message: ResponseMessages.StudyGroup.ErrorRemoveUser });
        }

        // REMOVE THE STUDY GROUP TO THE USER.
        let studyGroupWasRemoved = false;
        try {
            studyGroupWasRemoved = await user.removeStudyGroup(studyGroup);
        } catch (error) {
            Log.write("An error ocurred while attempting to remove a study group from a user.");
            Log.writeError(error);
            response.status(ResponseCodes.Error);
        }
        if (!studyGroupWasRemoved) {
            return response.json({ message: ResponseMessages.StudyGroup.ErrorRemoveStudyGroup });
        }

        // SEND THE SUCCESS MESSAGE
        return response.json({ message: ResponseMessages.StudyGroup.SuccessStudyGroupLeft });
    }

    /**
     * Allows the study group owner to set a recurring meeting.
     * @param {String} request.body.day The day of the meeting.
     * @param {String} request.body.frequency How often the meeting occurs.
     * @param {String} request.body.studyGroupId The group ID.
     * @param {String} request.body.time The time the meeting occurs.
     * @param {String=} request.body.date The date the meeting occurs.
     * @param {String=} request.body.details Information about the meeting.
     * @param {String=} request.body.location The location of the meeting.
     * @param {String=} request.body.roomNumber The room number of the meeting location.
     * @author Cameron Burkholder
     * @date   02/18/2022
     * @async
     * @static
     */
    static async setRecurringMeeting(request, response) {
        // CHECK THAT THE USER IS THE OWNER OF THE STUDY GROUP.
        const user = request.user;
        const studyGroupId = request.body.studyGroupId;
        let studyGroup = await StudyGroup.getById(studyGroupId);
        // Check that the study group exists.
        const studyGroupWasFound = Validator.isDefined(studyGroup);
        if (!studyGroupWasFound) {
            return reponse.json({ message: ResponseMessages.StudyGroup.UserNotOwner });
        }

        // CHECK IF THE USER IS THE OWNER OF THE STUDY GROUP.
        const userIsOwner = studyGroup.userIsOwner(user);
        if (!userIsOwner) {
            return response.json({ message: ResponseMessages.StudyGroup.UserNotOwner });
        }

        // GET THE RECURRING MEETING.
        // If the study group already has a recurring meeting set,
        // that one should be changed to reflect the new data.
        // If there isn't a recurring meeting already, one should be created.
        const recurringMeetingExists = Validator.isDefined(studyGroup.recurringMeeting);
        const { day, frequency, time, date, details, location, roomNumber } = request.body;
        if (recurringMeetingExists) {
            // GET THE RECURRING MEETING.
            const recurringMeeting = await Meeting.getById(studyGroup.recurringMeeting);

            //Convert the day from a number to a string
            const newDay = Object.keys(Days)[day];

            // SET THE RECURRING MEETING ATTRIBUTES.
            let meetingUpdated = true;
            meetingUpdated = meetingUpdated &amp;&amp; (await recurringMeeting.setDay(newDay));
            meetingUpdated = meetingUpdated &amp;&amp; (await recurringMeeting.setFrequency(frequency));
            meetingUpdated = meetingUpdated &amp;&amp; (await recurringMeeting.setTime(time));
            meetingUpdated = meetingUpdated &amp;&amp; (await recurringMeeting.setDate(date));
            meetingUpdated = meetingUpdated &amp;&amp; (await recurringMeeting.setDetails(details));
            meetingUpdated = meetingUpdated &amp;&amp; (await recurringMeeting.setLocation(location));
            meetingUpdated = meetingUpdated &amp;&amp; (await recurringMeeting.setRoomNumber(roomNumber));
            if (meetingUpdated) {
                return response.json({ message: ResponseMessages.StudyGroup.SetRecurringMeeting.Success });
            } else {
                return response.json({ message: ResponseMessages.StudyGroup.SetRecurringMeeting.Error });
            }
        } else {
            // CREATE THE MEETING.
            const recurringMeeting = await Meeting.create(day, frequency, time, date, details, location, roomNumber);

            // SET THE RECURRING MEETING.
            const meetingId = recurringMeeting.getId();
            let recurringMeetingWasSet = await studyGroup.setRecurringMeeting(meetingId);
            if (!recurringMeetingWasSet) {
                return response.json({ message: ResponseMessages.StudyGroup.SetRecurringMeeting.Error });
            } else {
                return response.json({ message: ResponseMessages.StudyGroup.SetRecurringMeeting.Success });
            }
        }
    }
}
module.exports = StudyGroupRouter;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="AccountRouter.html">AccountRouter</a></li><li><a href="Authenticator.html">Authenticator</a></li><li><a href="Configuration.html">Configuration</a></li><li><a href="Conversation.html">Conversation</a></li><li><a href="Feed.html">Feed</a></li><li><a href="JsonWebTokenStrategyOptions.html">JsonWebTokenStrategyOptions</a></li><li><a href="Log.html">Log</a></li><li><a href="Meeting.html">Meeting</a></li><li><a href="MeetingAvailability.html">MeetingAvailability</a></li><li><a href="Message.html">Message</a></li><li><a href="Post.html">Post</a></li><li><a href="SearchRouter.html">SearchRouter</a></li><li><a href="StaticResourceRouter.html">StaticResourceRouter</a></li><li><a href="StudyGroup.html">StudyGroup</a></li><li><a href="StudyGroupRouter.html">StudyGroupRouter</a></li><li><a href="Time.html">Time</a></li><li><a href="UnverifiedUser.html">UnverifiedUser</a></li><li><a href="User.html">User</a></li><li><a href="Validator.html">Validator</a></li></ul><h3>Global</h3><ul><li><a href="global.html#Account">Account</a></li><li><a href="global.html#AccountSetupForm">AccountSetupForm</a></li><li><a href="global.html#AccountSetupView">AccountSetupView</a></li><li><a href="global.html#allReducers">allReducers</a></li><li><a href="global.html#App">App</a></li><li><a href="global.html#authReducer">authReducer</a></li><li><a href="global.html#Button">Button</a></li><li><a href="global.html#ButtonTypes">ButtonTypes</a></li><li><a href="global.html#ConversationSchema">ConversationSchema</a></li><li><a href="global.html#CreateAccountForm">CreateAccountForm</a></li><li><a href="global.html#CreateAccountView">CreateAccountView</a></li><li><a href="global.html#CreateMeetingView">CreateMeetingView</a></li><li><a href="global.html#CreatePostView">CreatePostView</a></li><li><a href="global.html#CreateStudyGroupForm">CreateStudyGroupForm</a></li><li><a href="global.html#CreateStudyGroupView">CreateStudyGroupView</a></li><li><a href="global.html#DetailsView">DetailsView</a></li><li><a href="global.html#Dropdown">Dropdown</a></li><li><a href="global.html#EditStudyGroupView">EditStudyGroupView</a></li><li><a href="global.html#FeedSchema">FeedSchema</a></li><li><a href="global.html#Form">Form</a></li><li><a href="global.html#generateRSAKeyPair">generateRSAKeyPair</a></li><li><a href="global.html#Home">Home</a></li><li><a href="global.html#InputField">InputField</a></li><li><a href="global.html#Label">Label</a></li><li><a href="global.html#LoginForm">LoginForm</a></li><li><a href="global.html#LoginView">LoginView</a></li><li><a href="global.html#MeetingFormats">MeetingFormats</a></li><li><a href="global.html#MeetingSchema">MeetingSchema</a></li><li><a href="global.html#MessageSchema">MessageSchema</a></li><li><a href="global.html#Notification">Notification</a></li><li><a href="global.html#notificationReducer">notificationReducer</a></li><li><a href="global.html#Page">Page</a></li><li><a href="global.html#Popup">Popup</a></li><li><a href="global.html#popupReducer">popupReducer</a></li><li><a href="global.html#PostSchema">PostSchema</a></li><li><a href="global.html#PostTypes">PostTypes</a></li><li><a href="global.html#PrivacySettings">PrivacySettings</a></li><li><a href="global.html#ResponseCodes">ResponseCodes</a></li><li><a href="global.html#ResponseMessages">ResponseMessages</a></li><li><a href="global.html#Routes">Routes</a></li><li><a href="global.html#Search">Search</a></li><li><a href="global.html#SearchForm">SearchForm</a></li><li><a href="global.html#SearchListing">SearchListing</a></li><li><a href="global.html#SearchResultView">SearchResultView</a></li><li><a href="global.html#SearchView">SearchView</a></li><li><a href="global.html#sendDeleteRequest">sendDeleteRequest</a></li><li><a href="global.html#sendGetRequest">sendGetRequest</a></li><li><a href="global.html#sendPostRequest">sendPostRequest</a></li><li><a href="global.html#sendPostRequestWithFormData">sendPostRequestWithFormData</a></li><li><a href="global.html#StaticResources">StaticResources</a></li><li><a href="global.html#Study">Study</a></li><li><a href="global.html#StudyGroupSchema">StudyGroupSchema</a></li><li><a href="global.html#studyGroupsReducer">studyGroupsReducer</a></li><li><a href="global.html#StudyGroupTypes">StudyGroupTypes</a></li><li><a href="global.html#StudyGroupView">StudyGroupView</a></li><li><a href="global.html#Subjects">Subjects</a></li><li><a href="global.html#TextInput">TextInput</a></li><li><a href="global.html#Toggle">Toggle</a></li><li><a href="global.html#ToggleField">ToggleField</a></li><li><a href="global.html#UnverifiedUserSchema">UnverifiedUserSchema</a></li><li><a href="global.html#UserSchema">UserSchema</a></li><li><a href="global.html#VerificationEmailConfirmationView">VerificationEmailConfirmationView</a></li><li><a href="global.html#ViewMeetingView">ViewMeetingView</a></li><li><a href="global.html#Views">Views</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.7</a> on Mon Mar 07 2022 18:59:55 GMT-0500 (Eastern Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
